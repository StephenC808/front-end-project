---
interface Props {
	min: number;
	max: number;
}

let { min, max } = Astro.props;

if (!min) {min=1}
if (!max) {max=20}

---
<section class="container">
	<div class="row">
		<form>
			<label for="StartDate">Start Date:</label>
			<input type="date" id="StartDate" name="StartDate">
				  
			<label for="EndDate">End Date:</label>
			<input type="date" id="EndDate" name="EndDate">
				  
			<label for="input-text-field">Location:</label>
			<input id="input-text-field" name="input-text-field" type="text" placeholder="Enter your Location" required>
				  
			<input type="radio" id="daily" name="Granularity" value="daily">
			<label for="daily">Daily</label>
			<input type="radio" id="hourly" name="Granularity" value="hourly">
			<label for="hourly">Hourly</label>
				  
			<button id="button" type="button" >Submit</button>
		</form>
	</div>

</section>

<section class="container component-factorial py-2">
  <div>
    <canvas id="myChart"></canvas>
  </div>
</section>


<style></style>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>

  import Chart from 'chart.js/auto'
  const ctx = document.getElementById('myChart');

  const button = document.querySelector('#button');
  let start="";
  let end="";
  let location="";
  let theChart;

  let date = new Date();
  let max_date = new Date(date).setDate(date.getDate() + 1);
  let maxDate = new Date(max_date).toISOString().split('T')[0]

  let min_date = new Date(date).setDate(date.getDate() -7);
  let minDate = new Date(min_date).toISOString().split('T')[0]

  document.getElementById("StartDate").setAttribute("max", maxDate);
  document.getElementById("EndDate").setAttribute("max", maxDate);

  document.getElementById("StartDate").setAttribute("min", minDate);
  document.getElementById("EndDate").setAttribute("min", minDate);
  //document.querySelectorAll('input[type=text]').setAttribute("max", maxDate);
  //console.log(maxDate);

  //let max_date = date.setDate(date.getDate()+1);

  //console.log(maxDate.toISOString().split('T')[0]);
  let day = date.getDate();
  let month = date.getMonth() + 1;
  let year = date.getFullYear();

  // This arrangement can be altered based on how we want the date's format to appear.
  let currentDate = `${year}-${month}-${day}`;
  console.log(currentDate); // "17-6-2022"

  // <button> does not generate a 'submit' event. Use 'click' instead 
  button.addEventListener('click', getValues);

  function getValues() {
    // Get the value of the input field with id="numb"
    
    let startDate = document.getElementById("StartDate");
    let start = startDate.value;
    let endDate = document.getElementById("EndDate");
    let end = endDate.value;
    let locationOBJ = document.getElementById("input-text-field");
    let location = locationOBJ.value;

    // If x is Not a Number or less than one or greater than 10
    console.log(start);
    console.log(end);
    console.log(location);
    tester(start, end, location);

  }

  async function tester(start,end,location) {
    //`http://api.weatherapi.com/v1/current.json?key=290d085fbcf34ab78fa184457241607&q=${county}&aqi=no`
    //const response = await fetch(`http://api.weatherapi.com/v1/history.json?key=290d085fbcf34ab78fa184457241607&q=London&dt=2024-08-01`);
    //const response = await fetch(`http://api.weatherapi.com/v1/history.json?key=290d085fbcf34ab78fa184457241607&q=London&dt=${start}`);
    let fetchString=``;
    if (end){
      fetchString=`http://api.weatherapi.com/v1/history.json?key=290d085fbcf34ab78fa184457241607&q=${location}&dt=${start}&end_dt=${end}`;
    }
    else{
      fetchString=`http://api.weatherapi.com/v1/history.json?key=290d085fbcf34ab78fa184457241607&q=${location}&dt=${start}`;
    }
    const response = await fetch(fetchString);
    const data = await response.json();
    //console.log(data.forecast.forecastday[0].hour);
    console.log(data);
    var temp_labels=[];
    var temp_data=[];
    
    for (let j = 0; j < data.forecast.forecastday.length; j++) {
      for (let i = 0; i < data.forecast.forecastday[j].hour.length; i++) {
        //console.log(i);
        temp_labels.push(data.forecast.forecastday[j].hour[i].time);
        temp_data.push(data.forecast.forecastday[j].hour[i].temp_c);

      } 
    }
    
    if (theChart) {theChart.destroy();} // allows reselection without reloading the page
    //theChart.destroy();
    theChart = new Chart(ctx, {
      type: 'line',
      data: {
        //temp_labels//labels: ['Red', 'Blue', 'Yellow', 'Green', 'Purple', 'Orange'],
        datasets: [{
          label: '# of Votes',
          data: temp_data,
          borderWidth: 1
        }],
        labels: temp_labels
      },
      options: {
        scales: {
          y: {
            beginAtZero: false
          }
        }
      }
    });

    //theChart.destroy()
  }
</script>